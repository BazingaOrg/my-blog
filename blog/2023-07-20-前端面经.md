<h3 align="center">前端面经</h3>

#### 1. 从浏览器地址栏输入 url 到请求返回发生了什么？

​	(1) 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求，查找缓存。

			+ 强缓存：当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`（优先级高），其中cache-control的值有no-cache（可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304））、max-age=xxx（缓存最大过期时间，以秒为单位）、no-store（永远都不要在客户端存储资源，永远都去原始服务器去获取资源），强缓存生效，返回304；强缓存失效，进入协商缓存。其中，正常操作：地址栏输入 url，跳转链接，前进后退等，**强缓存、协商缓存都有效**；手动刷新：f5，点击刷新按钮，右键菜单刷新，**强缓存失效、协商缓存有效**；强制刷新：ctrl + f5，shift+command+r，**强缓存、协商缓存都失效**。
			+ 协商缓存：协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`（优先级高）。协商缓存主要有以下两种情况：1. 协商缓存生效，返回304；2. 协商缓存失效，返回200和请求结果。

​    (2) DNS 域名解析。

​	(3) TCP 连接，三次握手：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可   		靠传输，那么就需要**确认双方的接收和发送能力**。第一次握手可以确认客服端的**发送能力**，第二次握手，确认了服务端的**发送能力		和接收能力**，所以第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象。

​	(4) http 请求。

​	(5) 服务器处理请求并返回 HTTP 报文。

​	(6) 浏览器渲染页面：如果响应是HTML页面，浏览器会解析HTML、CSS和JavaScript代码，构建DOM树、CSSOM树和渲染树，最终在		屏幕上渲染出页面。

​	(7) 断开TCP链接，四次挥手：四次挥手的过程是因为 TCP 是全双工的通信协议，双方的关闭过程是相互独立的，所以需要各自进行两		次挥手。在第三次握手和第四次挥手之间，客户端会等待一个时间，这个时间是为了确保服务器收到了客户端的确认，如果在等待时		间内没有收到服务器的确认，客户端会重新发送 ACK 报文。一旦双方都完成了四次挥手过程，连接就被正式关闭。

#### 2. new 实现

​	(1) 首先创一个新的空对象。

​	(2) 根据原型链，设置空对象的 `__proto__` 为构造函数的 `prototype` 。

​	(3) 构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。

​	(4) 判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。

```javascript
function myNew(context) {
  const obj = new Object();
  obj.__proto__ = context.prototype;
  const res = context.apply(obj, [...arguments].slice(1));
  return typeof res === "object" ? res : obj;
}
```

#### 3. 浏览器的垃圾回收机制

​	有两种垃圾回收策略：

  + **标记清除**: 标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。
  + **引用计数**: 它把**对象是否不再需要**简化定义为**对象有没有其他对象引用到它**。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。

​    V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。

		+ 针对新生区采用并行回收。
		+ 针对老生区采用增量标记与惰性回收。

#### 4. useEffect 和 useLayoutEffect 区别

​	对于 React 的函数组件来说，其更新过程大致分为以下步骤：

​	(1) 因为某个事件 `state` 发生变化。

​	(2) React 内部更新 `state` 变量。

​	(3) React 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。

​	(4) 将更新过后的 DOM 数据绘制到浏览器中。

​	(5) 用户看到新的页面。

​	`useEffect` 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 `useLayoutEffect` 在第 3 步至第 4 步之间执行，且是同	步代码，所以会阻塞后面代码的执行。

#### 5. React 性能优化手段

​	(1) 使用 `React.memo` 来缓存组件。

​	(2) 使用 `React.useMemo` 缓存大量的计算。

​	(3) 避免使用匿名函数。

​	(4) 利用 `React.lazy` 和 `React.Suspense` 延迟加载不是立即需要的组件。

​	(5) 尽量使用 CSS 而不是强制加载和卸载组件。

​	(6) 使用 `React.Fragment` 避免添加额外的 DOM。

#### 6. 性能优化

​	(1) 代码层面：

		+ 防抖和节流（resize，scroll，input）。
		+ 减少回流（重排）和重绘。
		+ 事件委托。
		+ css 放 ，js 脚本放 最底部。
		+ 减少 DOM 操作。
		+ 按需加载，比如 React 中使用 `React.lazy` 和 `React.Suspense` ，通常需要与 webpack 中的 `splitChunks` 配合。

​    (2) 构建方面：

		+ **压缩代码文件**，在 webpack 中使用 `terser-webpack-plugin` 压缩 Javascript 代码；使用 `css-minimizer-webpack-plugin` 压缩 CSS 代码；使用 `html-webpack-plugin` 压缩 html 代码。
		+ **开启 gzip 压缩**，webpack 中使用 `compression-webpack-plugin` ，node 作为服务器也要开启，使用 `compression`。
		+ **常用的第三方库使用 CDN 服务**，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。

​    (3) 其它：

		+ 使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。
		+ 使用服务端渲染。
		+ 图片压缩。
		+ 使用 http 缓存，比如服务端的响应中添加 `Cache-Control / Expires` 。

#### 7. 事件循环

​	JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列	的代表就是，`Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval`。

​	事件循环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。

事件循环可以简单的描述为以下四个步骤:

​	(1) 函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；

​	(2) 期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）;

​	(3) 执行栈为空时，Event Loop把微任务队列执行清空；

​	(4) 微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的	话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。

#### 8. 节流防抖原理、区别以及应用

​	`节流`：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。

​	`防抖`：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！

​	节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……

​	防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。

#### 9. React/Vue 项目中 key 的作用

+ key的作用是为了在diff算法执行时更快的找到对应的节点，`提高diff速度，更高效的更新虚拟DOM`；

  vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。

+ 为了在数据变化时强制更新组件，以避免`“就地复用”`带来的副作用。

  当 Vue.js 用 `v-for` 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误

#### 10. nextTick 的实现

	1. `nextTick`是`Vue`提供的一个全局`API`,是在下次`DOM`更新循环结束之后执行延迟回调，在修改数据之后使用`$nextTick`，则可以在回调中获取更新后的`DOM`；
 	2. Vue在更新DOM时是异步执行的。只要侦听到数据变化，`Vue`将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个`watcher`被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和`DOM`操作是非常重要的。`nextTick`方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；
 	3. 比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；
 	4. 也有简单了解`nextTick`实现，它会在`callbacks`里面加入我们传入的函数，然后用`timerFunc`异步方式调用它们，首选的异步方式会是`Promise`。这让我明白了为什么可以在`nextTick`中看到`dom`操作结果。

#### 11. nextTick 的实现原理是什么

​	在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

#### 12. keep-alive 的实现

​	作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染

​	场景：tabs标签页 后台导航，vue性能优化

​	原理：`Vue.js`内部将`DOM`节点抽象成了一个个的`VNode`节点，`keep-alive`组件的缓存也是基于`VNode`节点的而不是直接存储`DOM`结构。它将满足条件`（pruneCache与pruneCache）`的组件在`cache`对象中缓存起来，在需要重新渲染的时候再将`vnode`节点从`cache`对象中取出并渲染。

#### 13. 简单描述一下 Babel 的编译过程

​	Babel 是一个 JavaScript 编译器，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

​	`Babel` 本质上就是在操作 `AST` 来完成代码的转译。AST是抽象语法树（Abstract Syntax Tree, AST）

​	`Babel` 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：

	1. **解析（Parse）** ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。
 	2. **转换（Transform）** ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。
 	3. **生成（Generate）** ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。

#### 14. webpack 做过哪些优化，开发效率方面、打包策略方面等等

​	1. **优化 Webpack 的构建速度**

		+ 使用高版本的 Webpack （使用webpack4）
		+ 多线程 / 多实例构建：thread-loader
  + 缩小打包作用域：
    - exclude/include (确定 loader 规则范围)
    - resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)
    - resolve.extensions 尽可能减少后缀尝试的可能性
    - noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)
    - IgnorePlugin (完全排除模块)
    - 合理使用alias

+ 充分利用缓存提升二次构建速度：
  + babel-loader 开启缓存
  + terser-webpack-plugin 开启缓存
  + 使用 cache-loader 或者 hard-source-webpack-plugin
    注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader

           2. **优化 Webpack 的打包体积**

+ 压缩代码
+ 提取页面公共资源：
+ Tree shaking
+ Scope hoisting
+ 图片压缩